<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples 线段树+二分合并]]></title>
    <url>%2F2019%2F10%2F01%2FHDU6406%2F</url>
    <content type="text"><![CDATA[HDU 6406 Problem DescriptionThere is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1, h2, …, hn, you are required to answer some independent queries. Each query is two integers p, q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? InputThe first line of input is a single line of integer T (1 ≤ T ≤ 10), the number of test cases. Each test case begins with a line of two integers n, m (1 ≤ n, m ≤ 105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1, h2, …, hn (1 ≤ hi ≤ 109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1 ≤ p ≤ n) and q (1 ≤ q ≤ 109), as described in the problem statement. OutputFor each query, display the answer in a single line. 题意给你一个序列，序列的第一个数必取，从前往后，当碰到比前一个数严格大于的数就选取。M次修改序列中的值，问修改后的序列能选取的个数。询问不叠加。 题解首先，根据题意，我们可以建立一颗线段树，维护区间的最大值mx和能选取的长度len，问题就在于两个区间如何合并。当我们合并根节点rt时，能选取的长度len[rt]=len[L]+右区间能选取的长度，我们通过二分搜索右区间来解决。 当发现rls区间的最大值mx[rls]&lt;=mx[L],显然，应该直接忽略rls，搜索rrs; 当发现rls区间的最大值mx[rls]&gt;mx[L],此时，rls必有可选的元素，且此时区间最大值mx会等于mx[rls]，则右区间rrs可选的长度不变，为len[r]-len[rls]; 当递归区间l==r时，我们判断mx[L]跟当前元素的关系。 Example Input12345615 31 2 3 4 41 55 52 3 Example Output123153 C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const int N = 1e5 + 50;int mx[N * 4], len[N * 4], n, m, a[N], T;int dfs(int p, int l, int r, int v)&#123; if (l == r) return v &lt; mx[p]; else if (mx[p &lt;&lt; 1] &lt;= v) return dfs(p &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, v); else return dfs(p &lt;&lt; 1, l, (l + r) &gt;&gt; 1, v) + len[p] - len[p &lt;&lt; 1];&#125;void build(int p, int l, int r)&#123; if (l == r) &#123; mx[p] = a[l]; len[p] = 1; return ; &#125; int m = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, m); build(p &lt;&lt; 1 | 1, m + 1, r); mx[p] = max(mx[p &lt;&lt; 1], mx[p &lt;&lt; 1 | 1]); len[p] = len[p &lt;&lt; 1] + dfs(p &lt;&lt; 1 | 1, m + 1, r, mx[p &lt;&lt; 1]);&#125;void update(int p, int l, int r, int x, int v)&#123; if (l == r) &#123; mx[p] = v; return ; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) update(p &lt;&lt; 1, l, m, x, v); else update(p &lt;&lt; 1 | 1, m + 1, r, x, v); mx[p] = max(mx[p &lt;&lt; 1], mx[p &lt;&lt; 1 | 1]); len[p] = len[p &lt;&lt; 1] + dfs(p &lt;&lt; 1 | 1, m + 1, r, mx[p &lt;&lt; 1]);&#125;int main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif ios::sync_with_stdio(false); for (cin &gt;&gt; T; T--;) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); for (int x, v, i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; v; update(1, 1, n, x, v); cout &lt;&lt; len[1] &lt;&lt; endl; update(1, 1, n, x, a[x]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
</search>
