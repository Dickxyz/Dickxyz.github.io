<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU6039 Gear Up 线段树dfs序]]></title>
    <url>%2F2019%2F10%2F05%2FHDU6039%2F</url>
    <content type="text"><![CDATA[Problem Description constroy has some gears, whose radii may vary. Two gears may be adjacent due to one of the following conditions:they mesh together, which causes them to have equal linear velocity on edge; or they are fixed on the same shaft, which causes them to have equal angular velocity.He guarantees that there are no two gears that satisfy both of the above conditions, and there is at most one transmission path between every two gears, where a transmission path is a sequence of different gears, in which two consecutive gears are adjacent.Now, constroy assigns an angular velocity to one of these gears, and then he wants to know the largest angular velocity among them.But sd0061 thinks it is too easy for you, so he decides to replace some gears and then ask you the question. Input The input contains multiple (about 30) test cases.For each test case, the first line contains three integers n, m, q (0≤n,m,q≤105, m&lt;n), indicating the number of gears, the number of adjacent pairs and the number of operations respectively.The second line contains n integers, the i-th number of which is ri (ri∈{20,21,…,230}), denoting the radius of the i-th gear.Each of the next m lines contains three integers a, x, y (a∈{1,2}, 1≤x,y≤n, x≠y), representing that the x-th gear and the y-th one are adjacent due to the a-th condition.The next q lines describe the operations in chronological order. Each line contains three integers a, x, y (a∈{1,2}, 1≤x≤n, y∈{20,21,…,230}), representing an operation where:if a=1, the operation is to replace the x-th gear with another one of radius y;if a=2, the operation is to ask you to determine the maximum possible angular velocity among all the gears if constroy assigns an angular velocity of y to the x-th gear.Note that the gears are always at rest. Output For each test case, firstly, output “Case #x:” in one line (without quotes), where x indicates the case number starting from 1.Then, for each operation with a=2, output a real number in one line, denoting the natural logarithm of the maximum angular velocity, with the precision for exactly three digits after the decimal point. Example Input123456789101112131415161718194 3 41 4 16 21 2 41 2 32 1 41 1 161 2 42 4 41 4 164 3 52 16 4 82 1 21 2 31 1 42 1 41 3 82 1 161 4 12 1 8 Example Output123456Case #1:1.386Case #2:2.7733.4662.773 题意给定n个齿轮，齿轮之间有两种连接方式：角速度相等或线速度相等构成森林。有q次操作，一种操作是改变某个齿轮的半径，一种操作是给定某个齿轮一个角速度，求齿轮组中最大的角速度 题解题意要求我们求出所有齿轮相对于根节点的相对角速度，考虑到可以使用dfs序+线段树进行维护。由于有两种连接方式，所以分两种情况进行讨论： 对于与父亲节点用线边相连的点，当半径发生修改时应该修改与他的角边相连的子树 对于与父亲节点用角边相连的点，当半径发生修改时应该修改与他的线边相连的子树 根据中学物理我们知道对于线速度相等的点w1*r1=w2*r2，再加上题目数据半径均为2^{n},所以可以两边取对数转化为log_{2}w1+ log_{2}r1=log_{2}w2+log_{2}r2，可以将区间乘法转化为加法。处理时应该注意用并查集来判断集合，dfs时可以先搜索角边相连的点然后记录一个中序，再搜索线边相连的点，这样易于区间修改。 C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;using namespace std;const int N = 1e5 + 50;int n, m, q, rad[N], cnt, first[N], nxt[N * 2], to[N * 2], bz[N], p[N], len, l[N], r[N], mid[N], tim, c[N * 2], t[N * 4], val[N], lazy[N * 4];void pushDown(int p)&#123; lazy[p &lt;&lt; 1] += lazy[p]; lazy[p &lt;&lt; 1 | 1] += lazy[p]; t[p &lt;&lt; 1] += lazy[p]; t[p &lt;&lt; 1 | 1] += lazy[p]; lazy[p] = 0;&#125;void build(int p, int l, int r)&#123; if (l == r) &#123; t[p] = val[l]; return; &#125; int m = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, m); build(p &lt;&lt; 1 | 1, m + 1, r); t[p] = max(t[p &lt;&lt; 1], t[p &lt;&lt; 1 | 1]);&#125;void update(int p, int l, int r, int a, int b, int x)&#123; if (a &lt;= l and b &gt;= r) &#123; lazy[p] += x; t[p] += x; return; &#125; if (lazy[p]) pushDown(p); int m = (l + r) &gt;&gt; 1; if (a &lt;= m) update(p &lt;&lt; 1, l, m, a, b, x); if (b &gt; m) update(p &lt;&lt; 1 | 1, m + 1, r, a, b, x); t[p] = max(t[p &lt;&lt; 1], t[p &lt;&lt; 1 | 1]);&#125;int query(int p, int l, int r, int a, int b)&#123; if (a &lt;= l and b &gt;= r) &#123; return t[p]; &#125; if (lazy[p]) pushDown(p); int m = (l + r) &gt;&gt; 1, maxn = INT_MIN; if (a &lt;= m) maxn = max(maxn, query(p &lt;&lt; 1, l, m, a, b)); if (b &gt; m) maxn = max(maxn, query(p &lt;&lt; 1 | 1, m + 1, r, a, b)); return maxn;&#125;void add(int x, int y, int z)&#123; nxt[++len] = first[x]; first[x] = len; to[len] = y; c[len] = z;&#125;void dfs(int x, int fa, int dis)&#123; l[x] = ++tim; val[tim] = dis; for (int i = first[x]; i; i = nxt[i]) if (c[i] == 2 and to[i] != fa) &#123; dfs(to[i], x, dis); bz[to[i]] = c[i]; &#125; mid[x] = tim; for (int i = first[x]; i; i = nxt[i]) if (c[i] == 1 and to[i] != fa) &#123; dfs(to[i], x, dis + rad[x] - rad[to[i]]); bz[to[i]] = c[i]; &#125; r[x] = tim;&#125;int find(int x)&#123; return p[x] == 0 ? x : (p[x] = find(p[x]));&#125;int main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif ios::sync_with_stdio(false); while (scanf("%d%d%d", &amp;n, &amp;m, &amp;q) != EOF) &#123; len = tim = 0; cnt++; printf("Case #%d:\n", cnt); memset(l, 0, sizeof(l)); memset(p, 0, sizeof(p)); memset(first, 0, sizeof(first)); memset(t, 0, sizeof(t)); memset(lazy, 0, sizeof(lazy)); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;rad[i]), rad[i] = log2(rad[i]); for (int a, x, y, i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;a, &amp;x, &amp;y); add(x, y, a); add(y, x, a); x = find(x), y = find(y), p[x] = y; &#125; for (int i = 1; i &lt;= n; i++) if (p[i] == 0) &#123; dfs(i, 0, 0); &#125; build(1, 1, tim); for (int a, x, y, i = 1; i &lt;= q; i++) &#123; scanf("%d%d%d", &amp;a, &amp;x, &amp;y); y = log2(y); if (a == 1) &#123; if (bz[x] == 1) update(1, 1, tim, l[x], mid[x], rad[x] - y); else update(1, 1, tim, mid[x] + 1, r[x], y - rad[x]); rad[x] = y; &#125; else &#123; int fa = find(x); printf("%.3lf\n", (y - query(1, 1, tim, l[x], l[x]) + query(1, 1, tim, l[fa], r[fa])) * log(2.0)); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU3986 Harry Potter and the Final Battle 最短路]]></title>
    <url>%2F2019%2F10%2F03%2FHDU3986%2F</url>
    <content type="text"><![CDATA[Problem Description The final battle is coming. Now Harry Potter is located at city 1, and Voldemort is located at city n. To make the world peace as soon as possible, Of course, Harry Potter will choose the shortest road between city 1 and city n. But unfortunately, Voldemort is so powerful that he can choose to destroy any one of the existing roads as he wish, but he can only destroy one. Now given the roads between cities, you are to give the shortest time that Harry Potter can reach city n and begin the battle in the worst case. Input First line, case number t (t&lt;=20).Then for each case: an integer n (2&lt;=n&lt;=1000) means the number of city in the magical world, the cities are numbered from 1 to n. Then an integer m means the roads in the magical world, m (0&lt; m &lt;=50000). Following m lines, each line with three integer u, v, w (u != v,1 &lt;=u, v&lt;=n, 1&lt;=w &lt;1000), separated by a single space. It means there is a bidirectional road between u and v with the cost of time w. There may be multiple roads between two cities. Output Each case per line: the shortest time to reach city n in the worst case. If it is impossible to reach city n in the worst case, output “-1”. Example Input1234567891011121314153441 2 52 4 101 3 33 4 8321 2 52 3 10221 2 11 2 2 Example Output12315-12 题意给定一张图，求删除一条边后最短路最长是多少，如果不可达输出-1 题解图的范围较小，考虑枚举最短路上的每一条边，修改权值为最大后再跑一遍最短路，保存最大值即可。 由于是双向边，可从起点出发跑一遍最短路记为dis[],从终点出发跑一遍最短路记为rdis[]，对于每一条边{x,y,w},dis[x]+rdis[y]+w==dis[n]，这条边即为最短路上的边 应该特判最短路不存在时的情况 C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const int N=2e5+50;queue&lt;int&gt; q;int first[N],nxt[N*2],to[N*2],n,m,len,dis[N],rdis[N],ndis[N],T,c[N];bool inqueue[N];struct edge&#123; int x,y,w; void init(int a,int b,int c) &#123; x=a,y=b,w=c; &#125;&#125; g[N];void addedge(int x,int y,int z)&#123; nxt[++len]=first[x]; first[x]=len; to[len]=y; c[len]=z;&#125;void spfa(int *dis,int s)&#123; memset(inqueue,false,sizeof(inqueue)); for (int i=0;i&lt;=n;i++) dis[i]=21474834; dis[s]=0; inqueue[s]=true; q.push(s); while (!q.empty()) &#123; int x=q.front(); q.pop(); for (int i=first[x];i;i=nxt[i]) &#123; int y=to[i]; if (dis[x]+c[i]&lt;dis[y]) &#123; dis[y]=dis[x]+c[i]; if (!inqueue[y]) &#123; inqueue[y]=true; q.push(y); &#125; &#125; &#125; inqueue[x]=false; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); for (cin&gt;&gt;T;T--;) &#123; memset(first,0,sizeof(first)); len=0; cin&gt;&gt;n&gt;&gt;m; for (int x,y,w,i=1;i&lt;=m;i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; addedge(x,y,w); addedge(y,x,w); g[i].init(x,y,w); &#125; spfa(dis,1); spfa(rdis,n); if (dis[n]==21474834) &#123; cout&lt;&lt;-1&lt;&lt;endl; continue; &#125; bool flag=false; int ans=0; for (int i=1;i&lt;=m;i++) if (dis[g[i].x]+rdis[g[i].y]+g[i].w==dis[n] or rdis[g[i].x]+dis[g[i].y]+g[i].w==dis[n]) &#123; c[i*2-1]=c[i*2]=214748364; spfa(ndis,1); if (ndis[n]==ndis[0]) &#123; flag=true; break; &#125; ans=max(ans,ndis[n]); c[i*2-1]=c[i*2]=g[i].w; &#125; if (flag) ans=-1; cout&lt;&lt;ans&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>最短路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4033 树上染色 树形DP]]></title>
    <url>%2F2019%2F10%2F03%2FBZOJ4033%2F</url>
    <content type="text"><![CDATA[Problem Description 有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。问收益最大值是多少。 Input 第一行两个整数N,K。接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。输入保证所有点之间是联通的。N&lt;=2000,0&lt;=K&lt;=N Output 输出一个正整数，表示收益的最大值。 Example Input123455 21 2 31 5 12 3 12 4 2 Example Output12317【样例解释】将点1,2染黑就能获得最大收益。 题解考虑使用树形DP来做 DP状态表示为dp[x][j],表示在以x为根的子树中选取j个点作为黑点的最大值，siz[x]表示以x为根的子树的大小。 枚举子节点y得到一条父亲节点与子节点的一条边，不妨假设边的权值为c 枚举子节点上选取黑点的个数为l,则这条边产生的贡献为两边黑点的个数相乘加上两边白点的个数相乘再乘上边的权值，即c*(l*(k-l)+(siz[y]-l)*(n-k-(siz[y]-l))) 枚举黑点个数时应从大到小枚举避免重复计算 C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const long long N=2e3+50;long long first[N],nxt[N*2],to[N*2],c[N*2],len,n,m,siz[N],dp[N][N],k;void add(long long x,long long y,long long z)&#123; nxt[++len]=first[x]; first[x]=len; to[len]=y; c[len]=z;&#125;void dfs(int x,int fa)&#123; siz[x]=1; for (int i=first[x];i;i=nxt[i]) if (to[i]!=fa) &#123; int y=to[i]; dfs(y,x); for (int j=min(siz[x],k);j&gt;=0;j--) &#123; for (int l=min(siz[y],k);l&gt;=0;l--) &#123; dp[x][j+l]=max(dp[x][j+l],dp[y][l]+dp[x][j]+c[i]*(l*(k-l)+(siz[y]-l)*(n-k-(siz[y]-l)))); &#125; &#125; siz[x]+=siz[y]; &#125;&#125;signed main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif cin&gt;&gt;n&gt;&gt;k; for (int a,b,c,i=1;i&lt;n;i++) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; add(a,b,c); add(b,a,c); &#125; dfs(1,0); cout&lt;&lt;dp[1][k]&lt;&lt;endl;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU6035 Colorful Tree 树形DP]]></title>
    <url>%2F2019%2F10%2F02%2FHDU6035%2F</url>
    <content type="text"><![CDATA[Problem Description There is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer ci. The path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it. Calculate the sum of values of all possible paths, $\frac{n*(n-1)}{2}$ in total, between two different nodes on the tree. Input The input contains multiple (about 50) test cases. For each test case, the first line contains an integer n (2≤n≤2×105), indicating the number of nodes. The next line contains n integers, the i-th number of which is ci (1≤ci≤n), denoting the color of the i-th node. Each of the next (n−1) lines contains two integers x, y (1≤x,y≤n, x≠y), representing an edge between the x-th node and the y-th one. It is guaranteed that given edges form a tree. Output For each test case, output “Case #x: y” in one line (without quotes), where x indicates the case number starting from 1, and y denotes the answer to the corresponding case. Example Input123456789101131 2 11 22 361 2 1 3 2 11 21 32 42 53 6 Example Output12Case #1: 6Case #2: 29 题意给定一棵树，树上每个节点都有一个颜色，求对于每条路径经过的颜色数之和，对于每一条路径，颜色相同的不重复计算。 题解考虑用树形DP来解决。 原问题可转化为路径总数减去不经过该种颜色的路径数 路径总数为$\frac{n^{2}*(n-1)}{2}$ 不经过该种颜色的路径数分为两种情况 在树形DP过程中可以确定块中的两个颜色相同点之间的点数cnt，则在这种情况下不经过该种颜色的路径数为$\frac{cnt*(cnt-1)}{2}$ 我们在DP结束后可以确定每一个颜色块的大小，(n-块的大小)这些点都不经过该种颜色，在这种情况下不经过该种颜色的路径数为$\frac{(n-块的大小)*((n-块的大小)-1))}{2}$ C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const long long N=2e5+50;long long first[N],nxt[N*2],to[N*2],c[N],len,n,m,son[N],sum[N],a[N],ans;void add(long long x,long long y)&#123; nxt[++len]=first[x]; first[x]=len; to[len]=y;&#125;void dfs(long long x,long long fa)&#123; son[x]=1; long long pre=sum[c[x]]; long long num=0; for (long long i=first[x];i;i=nxt[i]) if (to[i]!=fa) &#123; long long y=to[i]; dfs(y,x); son[x]+=son[y]; long long now=sum[c[x]],cnt=son[y]-(now-pre); pre=now; num+=cnt; ans-=cnt*(cnt-1)/2; &#125; sum[c[x]]+=1+num;&#125;signed main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif long long cnt=0; while (scanf("%lld",&amp;n)==1) &#123; memset(first,0,sizeof(first)); memset(sum,0,sizeof(sum)); memset(son,0,sizeof(son)); len=0; for (long long i=1;i&lt;=n;i++) scanf("%lld",&amp;c[i]); for (long long x,y,i=1;i&lt;n;i++) &#123; scanf("%lld%lld",&amp;x,&amp;y); add(x,y); add(y,x); &#125; ans=n*n*(n-1)/2; dfs(1,0); for (long long i=1;i&lt;=n;i++) ans-=(n-sum[i])*(n-sum[i]-1)/2; printf("Case #%lld: %lld\n",++cnt,ans); &#125;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples 线段树+二分合并]]></title>
    <url>%2F2019%2F10%2F01%2FHDU6406%2F</url>
    <content type="text"><![CDATA[HDU 6406 Problem Description There is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1, h2, …, hn, you are required to answer some independent queries. Each query is two integers p, q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? Input The first line of input is a single line of integer T (1 ≤ T ≤ 10), the number of test cases. Each test case begins with a line of two integers n, m (1 ≤ n, m ≤ 105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1, h2, …, hn (1 ≤ hi ≤ 109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1 ≤ p ≤ n) and q (1 ≤ q ≤ 109), as described in the problem statement. Output For each query, display the answer in a single line. Example Input12345615 31 2 3 4 41 55 52 3 Example Output123153 题意给你一个序列，序列的第一个数必取，从前往后，当碰到比前一个数严格大于的数就选取。M次修改序列中的值，问修改后的序列能选取的个数。询问不叠加。 题解首先，根据题意，我们可以建立一颗线段树，维护区间的最大值mx和能选取的长度len，问题就在于两个区间如何合并。当我们合并根节点rt时，能选取的长度len[rt]=len[L]+右区间能选取的长度，我们通过二分搜索右区间来解决。 当发现rls区间的最大值mx[rls]&lt;=mx[L],显然，应该直接忽略rls，搜索rrs; 当发现rls区间的最大值mx[rls]&gt;mx[L],此时，rls必有可选的元素，且此时区间最大值mx会等于mx[rls]，则右区间rrs可选的长度不变，为len[r]-len[rls]; 当递归区间l==r时，我们判断mx[L]跟当前元素的关系。 C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const int N = 1e5 + 50;int mx[N * 4], len[N * 4], n, m, a[N], T;int dfs(int p, int l, int r, int v)&#123; if (l == r) return v &lt; mx[p]; else if (mx[p &lt;&lt; 1] &lt;= v) return dfs(p &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, v); else return dfs(p &lt;&lt; 1, l, (l + r) &gt;&gt; 1, v) + len[p] - len[p &lt;&lt; 1];&#125;void build(int p, int l, int r)&#123; if (l == r) &#123; mx[p] = a[l]; len[p] = 1; return ; &#125; int m = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, m); build(p &lt;&lt; 1 | 1, m + 1, r); mx[p] = max(mx[p &lt;&lt; 1], mx[p &lt;&lt; 1 | 1]); len[p] = len[p &lt;&lt; 1] + dfs(p &lt;&lt; 1 | 1, m + 1, r, mx[p &lt;&lt; 1]);&#125;void update(int p, int l, int r, int x, int v)&#123; if (l == r) &#123; mx[p] = v; return ; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) update(p &lt;&lt; 1, l, m, x, v); else update(p &lt;&lt; 1 | 1, m + 1, r, x, v); mx[p] = max(mx[p &lt;&lt; 1], mx[p &lt;&lt; 1 | 1]); len[p] = len[p &lt;&lt; 1] + dfs(p &lt;&lt; 1 | 1, m + 1, r, mx[p &lt;&lt; 1]);&#125;int main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif ios::sync_with_stdio(false); for (cin &gt;&gt; T; T--;) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); for (int x, v, i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; v; update(1, 1, n, x, v); cout &lt;&lt; len[1] &lt;&lt; endl; update(1, 1, n, x, a[x]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
</search>
