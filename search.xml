<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU6035]]></title>
    <url>%2F2019%2F10%2F02%2FHDU6035%2F</url>
    <content type="text"><![CDATA[Problem Description There is a tree having n nodes, the i-th node of which has a type of color, denoted by an integer ci. The path between every two nodes is unique, of which we define the value is the number of distinct types of colors appearing on it. Calculate the sum of values of all possible paths, $\frac{a+b}{2}$ in total, between two different nodes on the tree. Input The input contains multiple (about 50) test cases. For each test case, the first line contains an integer n (2≤n≤2×105), indicating the number of nodes. The next line contains n integers, the i-th number of which is ci (1≤ci≤n), denoting the color of the i-th node. Each of the next (n−1) lines contains two integers x, y (1≤x,y≤n, x≠y), representing an edge between the x-th node and the y-th one. It is guaranteed that given edges form a tree. OutputFor each test case, output “Case #x: y” in one line (without quotes), where x indicates the case number starting from 1, and y denotes the answer to the corresponding case. Example Input123456789101131 2 11 22 361 2 1 3 2 11 21 32 42 53 6 Example Output12Case #1: 6Case #2: 29 题意给定一棵树，树上每个节点都有一个颜色，求对于每条路径经过的颜色数之和，对于每一条路径，颜色相同的不重复计算。 题解考虑用树形DP来解决。 原问题可转化为路径总数减去不经过该种颜色的路径数 路径总数为$\frac{nn(n-1)}{2}$ 不经过该种颜色的路径数分为两种情况 在树形DP过程中可以确定块中的两个颜色相同点之间的点数cnt，则在这种情况下不经过该种颜色的路径数为$\frac{cnt*(cnt-1))}{2}$ 我们在DP结束后可以确定每一个颜色块的大小，(n-块的大小)这些点都不经过该种颜色，在这种情况下不经过该种颜色的路径数为$\frac{(n-块的大小)*((n-块的大小)-1))}{2}$C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const long long N=2e5+50;long long first[N],nxt[N*2],to[N*2],c[N],len,n,m,son[N],sum[N],a[N],ans;void add(long long x,long long y)&#123; nxt[++len]=first[x]; first[x]=len; to[len]=y;&#125;void dfs(long long x,long long fa)&#123; son[x]=1; long long pre=sum[c[x]]; long long num=0; for (long long i=first[x];i;i=nxt[i]) if (to[i]!=fa) &#123; long long y=to[i]; dfs(y,x); son[x]+=son[y]; long long now=sum[c[x]],cnt=son[y]-(now-pre); pre=now; num+=cnt; ans-=cnt*(cnt-1)/2; &#125; sum[c[x]]+=1+num;&#125;signed main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif long long cnt=0; while (scanf("%lld",&amp;n)==1) &#123; memset(first,0,sizeof(first)); memset(sum,0,sizeof(sum)); memset(son,0,sizeof(son)); len=0; for (long long i=1;i&lt;=n;i++) scanf("%lld",&amp;c[i]); for (long long x,y,i=1;i&lt;n;i++) &#123; scanf("%lld%lld",&amp;x,&amp;y); add(x,y); add(y,x); &#125; ans=n*n*(n-1)/2; dfs(1,0); for (long long i=1;i&lt;=n;i++) ans-=(n-sum[i])*(n-sum[i]-1)/2; printf("Case #%lld: %lld\n",++cnt,ans); &#125;&#125;]]></content>
      <categories>
        <category>树形DP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HDU 6406 Taotao Picks Apples 线段树+二分合并]]></title>
    <url>%2F2019%2F10%2F01%2FHDU6406%2F</url>
    <content type="text"><![CDATA[HDU 6406 Problem Description There is an apple tree in front of Taotao’s house. When autumn comes, n apples on the tree ripen, and Taotao will go to pick these apples. When Taotao picks apples, Taotao scans these apples from the first one to the last one. If the current apple is the first apple, or it is strictly higher than the previously picked one, then Taotao will pick this apple; otherwise, he will not pick. Given the heights of these apples h1, h2, …, hn, you are required to answer some independent queries. Each query is two integers p, q, which asks the number of apples Taotao would pick, if the height of the p-th apple were q (instead of hp). Can you answer all these queries? Input The first line of input is a single line of integer T (1 ≤ T ≤ 10), the number of test cases. Each test case begins with a line of two integers n, m (1 ≤ n, m ≤ 105), denoting the number of apples and the number of queries. It is then followed by a single line of n integers h1, h2, …, hn (1 ≤ hi ≤ 109), denoting the heights of the apples. The next m lines give the queries. Each of these m lines contains two integers p (1 ≤ p ≤ n) and q (1 ≤ q ≤ 109), as described in the problem statement. OutputFor each query, display the answer in a single line. Example Input12345615 31 2 3 4 41 55 52 3 Example Output123153 题意给你一个序列，序列的第一个数必取，从前往后，当碰到比前一个数严格大于的数就选取。M次修改序列中的值，问修改后的序列能选取的个数。询问不叠加。 题解首先，根据题意，我们可以建立一颗线段树，维护区间的最大值mx和能选取的长度len，问题就在于两个区间如何合并。当我们合并根节点rt时，能选取的长度len[rt]=len[L]+右区间能选取的长度，我们通过二分搜索右区间来解决。 当发现rls区间的最大值mx[rls]&lt;=mx[L],显然，应该直接忽略rls，搜索rrs; 当发现rls区间的最大值mx[rls]&gt;mx[L],此时，rls必有可选的元素，且此时区间最大值mx会等于mx[rls]，则右区间rrs可选的长度不变，为len[r]-len[rls]; 当递归区间l==r时，我们判断mx[L]跟当前元素的关系。 C++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;map&gt;#include&lt;stack&gt;using namespace std;const int N = 1e5 + 50;int mx[N * 4], len[N * 4], n, m, a[N], T;int dfs(int p, int l, int r, int v)&#123; if (l == r) return v &lt; mx[p]; else if (mx[p &lt;&lt; 1] &lt;= v) return dfs(p &lt;&lt; 1 | 1, ((l + r) &gt;&gt; 1) + 1, r, v); else return dfs(p &lt;&lt; 1, l, (l + r) &gt;&gt; 1, v) + len[p] - len[p &lt;&lt; 1];&#125;void build(int p, int l, int r)&#123; if (l == r) &#123; mx[p] = a[l]; len[p] = 1; return ; &#125; int m = (l + r) &gt;&gt; 1; build(p &lt;&lt; 1, l, m); build(p &lt;&lt; 1 | 1, m + 1, r); mx[p] = max(mx[p &lt;&lt; 1], mx[p &lt;&lt; 1 | 1]); len[p] = len[p &lt;&lt; 1] + dfs(p &lt;&lt; 1 | 1, m + 1, r, mx[p &lt;&lt; 1]);&#125;void update(int p, int l, int r, int x, int v)&#123; if (l == r) &#123; mx[p] = v; return ; &#125; int m = (l + r) &gt;&gt; 1; if (x &lt;= m) update(p &lt;&lt; 1, l, m, x, v); else update(p &lt;&lt; 1 | 1, m + 1, r, x, v); mx[p] = max(mx[p &lt;&lt; 1], mx[p &lt;&lt; 1 | 1]); len[p] = len[p &lt;&lt; 1] + dfs(p &lt;&lt; 1 | 1, m + 1, r, mx[p &lt;&lt; 1]);&#125;int main()&#123;#ifdef ONLINE_JUDGE#else freopen("r.txt", "r", stdin);#endif ios::sync_with_stdio(false); for (cin &gt;&gt; T; T--;) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; build(1, 1, n); for (int x, v, i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; x &gt;&gt; v; update(1, 1, n, x, v); cout &lt;&lt; len[1] &lt;&lt; endl; update(1, 1, n, x, a[x]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
  </entry>
</search>
